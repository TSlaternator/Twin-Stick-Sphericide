using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//Class to procedurally generate my Map
public class MapGeneration : MonoBehaviour {

	public int mapWidth; //width of my noiseMap
	public int mapHeight; //height of my noiseMap
	public float amplitudeModifier; //affects how much the amplitude decreases for each octave (value should be a value from 0 to 1)
	public float frequencyModifier; //affects how much the frequency increases for each octave (should be a value from 1+)
	public float zoom; //affects how zoomed in my slice of noise will be from the noise generated by unity
	public int octaves; //how many 'layers' of noise to use
	public int seed; //seed of the Noise to use

	//seperate variables for the moistureMap
	public float moistureAmplitudeModifier; //affects how much the moisture noise amplitude decreases for each octave (value should be from 0 to 1)
	public float moistureFrequencyModifier; //affects how much the moisture noise frequency increases for each octave (should be a value from 1+)
	public float moistureZoom; //affects how zoomed in my slice of moisture noise will be from the noise generated by unity
	public int moistureOctaves; //how many 'layers' of moisture noise to use
	public int moistureSeed;  //seed of the moisture noise to use

	//variables to control falloff gradient 
	public float falloffPower; //higher values mean the falloff is sharper
	public float falloffOffset; // higher values mean falloff occurs closer to the map edges

	public Biome[] biomes; //array of my Biome structs to hold my biomes

	public GameObject Map; //reference to the empty Map GameObject, all terrain objects will be children of this (to reduce clutter)
	public GameObject TreeMap; //reference to the empty TreeMap GameObject, all tree objects will be children of this (to reduce clutter)
	public GameObject GrassMap; //reference to the empty GrassMap GameObject, all grass objects will be children of this (to reduce clutter)

	public GameObject Director; //reference to the Director GameObject, allows me to set the spawnHeight and 'spawnable' attributes of each tile

	//variables used for generating the terrain
	private float connectedCount = 0; //counts how many objects in a row are the same type (used to reduce GameObject counts by merging them)
	private int startY = 0; //holds the y value of the start point of each new terrain type
	private int startX = 0; //holds the x value of the start point of each new terrain type
	private GameObject currentTerrain; //holds a reference to the current terrainType, used to check if next tile is the same type

	/*
	 * Method to generate my map from the noise, uses helper methods to generate the trees and grass
	 */ 
	public void GenerateMap() {
		//creating the individual maps which add together to make the overall map
		float[,] heightMap = NoiseGeneration.GenerateNoiseMap (mapWidth, mapHeight, seed, zoom, octaves, amplitudeModifier, frequencyModifier); 
		float[,] moistureMap = NoiseGeneration.GenerateNoiseMap (mapWidth, mapHeight, moistureSeed, moistureZoom, moistureOctaves, moistureAmplitudeModifier, moistureFrequencyModifier); 
		float[,] falloffMap = FalloffGeneration.GenerateFalloffMap (mapWidth, falloffPower, falloffOffset);

		currentTerrain = biomes[0].terrain; //first block will always be 'deepWater' so sets currentTerrain to 'deepWater'

		//loop to go through each point in my map, generate its terrain block, and have a chance to spawn trees and grass on it
		for (int x = 0; x < mapWidth; x++) {
			for (int y = 0; y < mapHeight; y++) {
				float noiseHeight = Mathf.Clamp01(heightMap [x, y] - falloffMap[x,y]); 
				float noiseMoisture = moistureMap [x, y]; 
				//loop to categorise the points into their biomes (based on the noiseHeight and noiseMoisture variables)
				for (int i = 0; i < biomes.Length; i++){
					if (noiseHeight <= biomes [i].height){
						Director.GetComponent<Director> ().SetSpawnHeight (x, y, biomes [i].terrainHeight + 0.5f);
						if (biomes [i].terrainHeight == 1)
							Director.GetComponent<Director> ().NotSpawnable (x, y); //sets water tiles (the only tiles with terrainHeight 1) to non spawnable
						if (noiseMoisture <= biomes [i].moisture) {
							spawnTerrain (biomes[i], x, y); //spawning in terrain
						    spawnGrass (biomes [i], x, y); //has a chance to spawn 'grass' on each block
							if (x % 2 != 0 && y % 2 != 0) //has a chance to place a tree every other block
								spawnTrees (biomes [i], x, y);
							break;
						}
					}
				}
			}
		}
	}

	/*
	 * Tries to spawn a tree, based on the settings of the biome supplied
	 */ 
	private void spawnTrees (Biome currentBiome, int x, int y){
		//random chance to create a tree, based on the tree density of each biome
		float plantTree = Random.Range (0f, 1f);
		if (plantTree <= currentBiome.treeChance) {
			//if a tree is placed on the terrain, set it to non-spawnable in the directors Array
			Director.GetComponent<Director> ().NotSpawnable (x, y); 
			float treeType = Random.Range (0f, 1f);
			//loop to place a random tree from the biomes list of possible trees
			for (int j = 0; j < currentBiome.treeTypes.Length; j++) {
				//once the tree type is chosen, spawn it at a random y axis rotation from (0, 90, 180, 270)
				if (treeType <= currentBiome.treeTypes[j].chance) {
					int rotation = Random.Range (0, 4);
					rotation *= 90;
					Instantiate (currentBiome.treeTypes[j].type, new Vector3 (x, currentBiome.terrainHeight, y + 0.5f), (Quaternion.identity * Quaternion.Euler(0, rotation, 0)), TreeMap.transform);
					break;
				}
			}
		}
	}

	/*
	 * Tries to spawn grass, based on the settings of the biome supplied
	 */ 
	private void spawnGrass (Biome currentBiome, int x, int y){
		//random chance to spawn 'grass', based on the spawn chance of the biome
		float spawnGrass = Random.Range (0f, 1f);
		if (spawnGrass <= currentBiome.grassChance) {
			float grassType = Random.Range (0f, 1f);
			//loop to place a random 'grass' from the biomes array of possible grasses
			for (int j = 0; j < currentBiome.grassTypes.Length; j++){
				//once the grass type is chosen, spawn it at a random y axis rotation from (0, 90, 180, 270)
				if (grassType <= currentBiome.grassTypes [j].chance) {
					int rotation = Random.Range (0, 4);
					rotation *= 90;
					Instantiate (currentBiome.grassTypes [j].type, new Vector3 (x, currentBiome.terrainHeight, y + 0.5f), (Quaternion.identity * Quaternion.Euler (0, rotation, 0)), GrassMap.transform);
					break;
				}
			}
		}
	}

	/*
	 * spawns terrain (walkable ground) based on the settings of the biome supplied
	 */ 
	private void spawnTerrain (Biome currentBiome, int x, int y){
		//if the next block is the same as the last block, and not the start of a new column - add one to connected count
		if (currentBiome.terrain == currentTerrain && y != 0) {
			connectedCount++;
		//if not then spawn the currentTerrain Object starting at startX, startY, with it's z value scaled to connected count
		} else {
			GameObject newObject = Instantiate(currentTerrain, new Vector3(startX, 0, startY + connectedCount / 2f), Quaternion.identity, Map.transform) as GameObject;
			newObject.transform.localScale = new Vector3 (newObject.transform.localScale.x, newObject.transform.localScale.y, connectedCount);

			//resetting the currentTerrain, connectedCount and start position
			currentTerrain = currentBiome.terrain;
			connectedCount = 1;
			startY = y;
			startX = x;
		}
		//also spawns the object if it's at the last element in the array
		if (x == mapHeight - 1 && y == mapWidth - 1) {
			GameObject newObject = Instantiate(currentTerrain, new Vector3(startX, 0, startY + connectedCount / 2f), Quaternion.identity, Map.transform) as GameObject;
			newObject.transform.localScale = new Vector3 (newObject.transform.localScale.x, newObject.transform.localScale.y, connectedCount);
		}
	}
}

/*
 * struct for holding the data and requirements of my biomes
 */
[System.Serializable] //allows it to show up in the inspector
public struct Biome{
	public string name; //name of the biome
	public float height; //noiseHeight the biome starts at
	public float moisture; //noiseMoisture the biome starts at
	public GameObject terrain; //actualy GameObject the terrain is made from
	public float terrainHeight; //height of the terrain (used for spawning enemies/pickups on the terrain)
	public float treeChance; //biomes chance of spawning trees
	public Tree[] treeTypes; //array to hold the tree structs
	public float grassChance; //biomes chance of spawning grass
	public Grass[] grassTypes; //array to hold the grass structs
}
	
/*
 * struct for holding the prefabs and spawn chance of my individual trees
 */
[System.Serializable]
public struct Tree{
	public string name; //name of the tree to be spawned
	public float chance; //minimum random value (from 0 to 1) this tree will start spawning at
	public GameObject type; //prefab of the tree to be spawned
}
	
/*
 * struct for holding the prefabs and spawn chance of my individual 'grasses'
 */
[System.Serializable]
public struct Grass{
	public string name; //name of the 'grass' to be spawned
	public float chance; //minimum random value (from 0 to 1) this grass will start spawning at
	public GameObject type; //prefab of the 'grass' to be spawned
}